<?php
/**
 * Banking DVWA Project
 * Vulnerability Unit Tests
 * 
 * This file contains unit tests for vulnerability implementations.
 */

namespace Tests\Unit;

use PHPUnit\Framework\TestCase;
use Vulnerabilities\VulnerabilityBase;

class VulnerabilityTest extends TestCase
{
    /**
     * Test vulnerability factory method
     */
    public function testVulnerabilityFactory()
    {
        // Test creating different vulnerabilities
        $sqlLow = VulnerabilityBase::factory('sql_injection', 'low');
        $this->assertInstanceOf('Vulnerabilities\sql_injection\LowSecurity', $sqlLow);
        
        $xssHigh = VulnerabilityBase::factory('xss', 'high');
        $this->assertInstanceOf('Vulnerabilities\xss\HighSecurity', $xssHigh);
        
        // Test invalid vulnerability
        $this->expectException(\InvalidArgumentException::class);
        VulnerabilityBase::factory('nonexistent_vulnerability', 'low');
    }
    
    /**
     * Test SQL Injection vulnerability with different security levels
     */
    public function testSqlInjection()
    {
        // Low security
        $sqlLow = VulnerabilityBase::factory('sql_injection', 'low');
        $this->assertEquals('sql_injection', $sqlLow->getType());
        
        // Test with a benign input
        $result = $sqlLow->execute(['username' => 'admin']);
        // We can't really test the full execution without a database
        $this->assertIsArray($result);
        
        // Medium security
        $sqlMedium = VulnerabilityBase::factory('sql_injection', 'medium');
        $this->assertInstanceOf('Vulnerabilities\sql_injection\MediumSecurity', $sqlMedium);
        
        // High security
        $sqlHigh = VulnerabilityBase::factory('sql_injection', 'high');
        $this->assertInstanceOf('Vulnerabilities\sql_injection\HighSecurity', $sqlHigh);
    }
    
    /**
     * Test XSS vulnerability sanitization
     */
    public function testXssSanitization()
    {
        // Create instances for different security levels
        $xssLow = VulnerabilityBase::factory('xss', 'low');
        $xssMedium = VulnerabilityBase::factory('xss', 'medium');
        $xssHigh = VulnerabilityBase::factory('xss', 'high');
        
        // Test script input
        $input = ['message' => '<script>alert("XSS");</script>'];
        
        // Low should not sanitize
        $resultLow = $xssLow->execute($input);
        $this->assertTrue($resultLow['success']);
        
        // Medium should attempt to filter scripts
        $resultMedium = $xssMedium->execute($input);
        $this->assertTrue($resultMedium['success']);
        $this->assertArrayHasKey('filtered_message', $resultMedium);
        $this->assertNotEquals($input['message'], $resultMedium['filtered_message']);
        
        // High should properly sanitize
        $resultHigh = $xssHigh->execute($input);
        $this->assertTrue($resultHigh['success']);
        
        // Test message rendering
        $scriptMessage = ['user' => 'test', 'message' => '<script>alert("XSS");</script>', 'timestamp' => time()];
        
        // Low should not escape script tags
        $renderedLow = $xssLow->renderMessage($scriptMessage);
        $this->assertStringContainsString('<script>', $renderedLow);
        
        // High should escape script tags
        $renderedHigh = $xssHigh->renderMessage($scriptMessage);
        $this->assertStringContainsString('&lt;script&gt;', $renderedHigh);
    }
    
    /**
     * Test Command Injection vulnerability with different security levels
     */
    public function testCommandInjection()
    {
        // Create instances for different security levels
        $cmdLow = VulnerabilityBase::factory('cmd_injection', 'low');
        $cmdMedium = VulnerabilityBase::factory('cmd_injection', 'medium');
        $cmdHigh = VulnerabilityBase::factory('cmd_injection', 'high');
        
        // Test with valid input
        $validInput = ['command' => 'ping', 'param' => 'localhost'];
        
        $resultLow = $cmdLow->execute($validInput);
        $this->assertNull($resultLow['error']);
        $this->assertStringContainsString('localhost', $resultLow['command']);
        
        $resultHigh = $cmdHigh->execute($validInput);
        $this->assertNull($resultHigh['error']);
        
        // Test with malicious input
        $maliciousInput = ['command' => 'ping', 'param' => 'localhost; cat /etc/passwd'];
        
        // Low should be vulnerable
        $resultLowMalicious = $cmdLow->execute($maliciousInput);
        $this->assertNull($resultLowMalicious['error']);
        
        // High should reject or sanitize
        $resultHighMalicious = $cmdHigh->execute($maliciousInput);
        $this->assertNotNull($resultHighMalicious['error']);
    }
    
    /**
     * Test Directory Traversal vulnerability
     */
    public function testDirectoryTraversal()
    {
        // Create instances for different security levels
        $dirLow = VulnerabilityBase::factory('directory_traversal', 'low');
        $dirMedium = VulnerabilityBase::factory('directory_traversal', 'medium');
        $dirHigh = VulnerabilityBase::factory('directory_traversal', 'high');
        
        // Test with valid input
        $validFile = 'statement_account1.pdf';
        $validInput = ['file' => $validFile];
        
        // We can't test actual execution without the files, but we can check logic
        $this->assertEquals('directory_traversal', $dirLow->getType());
        
        // Test available files
        $files = $dirLow->getAvailableFiles();
        $this->assertIsArray($files);
    }
}
